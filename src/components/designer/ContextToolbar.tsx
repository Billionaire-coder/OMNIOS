import React, { useState } from 'react';
import { useProjectStore } from '@/hooks/useProjectStore';
import { hyperBridge } from '@/lib/engine/HyperBridge';

interface ContextToolbarProps {
    elementId: string | null;
    canvasTransform: { x: number, y: number, scale: number };
    onOpenAnalytics: () => void;
}

export function ContextToolbar({ elementId, canvasTransform, onOpenAnalytics }: ContextToolbarProps) {
    const { state, removeElement, addElement, updateElementStyles, setSelectedElement, setEditingElementId, updateElementProp } = useProjectStore();

    if (!elementId) return null;

    // Helper to get element DOM rect
    const getRect = (id: string | null) => {
        if (!id) return null;
        const el = document.getElementById(id); // DOM rect
        if (!el) return null;
        return el.getBoundingClientRect();
    };

    const rect = getRect(elementId);
    if (!rect) return null;

    // Helper to duplicate (Shallow Clone for MVP)
    const handleDuplicate = (e: React.MouseEvent) => {
        e.stopPropagation();
        const element = state.elements[elementId];
        if (!element || !element.parentId) return;

        // Basic Clone: Same type, styles, content. New ID generated by addElement.
        // Deep cloning children would require recursive logic which `addElement` doesn't do natively yet.
        // For MVP: We clone the shell.
        const clone = {
            type: element.type,
            styles: { ...element.styles, top: undefined, left: undefined }, // Reset position if absolute to avoid overlap? Or keep?
            content: element.content,
            layoutMode: element.layoutMode
        };

        addElement(element.type, element.parentId, clone);
    };

    const handleDelete = (e: React.MouseEvent) => {
        e.stopPropagation();
        if (confirm('Delete element?')) {
            removeElement(elementId);
        }
    };

    const handleReset = (e: React.MouseEvent) => {
        e.stopPropagation();
        updateElementStyles(elementId, {
            margin: '0px',
            padding: '0px',
            width: undefined,
            height: undefined
        });
    };

    const handleParent = (e: React.MouseEvent) => {
        e.stopPropagation();
        const parentId = state.elements[elementId]?.parentId;
        if (parentId && parentId !== 'root') {
            setSelectedElement(parentId);
        } else if (parentId === 'root') {
            setSelectedElement('root');
        }
    };

    const handleMagicOptimize = (e: React.MouseEvent) => {
        e.stopPropagation();
        // Invoke Rust Simulation via WASM
        const result = hyperBridge.simulateLayout(500); // 500 iterations

        if (result && result.best_config) {
            const { padding, gap, justify_content, align_items } = result.best_config;

            updateElementStyles(elementId, {
                padding: `${padding}px`,
                gap: `${gap}px`,
                justifyContent: justify_content,
                alignItems: align_items,
                display: 'flex'
            });

            console.log(`[Neural AI] Layout Optimized. Score: ${result.score.toFixed(2)}`);
        }
    };

    const buttonStyle: React.CSSProperties = {
        background: 'transparent',
        border: 'none',
        color: '#ccc',
        cursor: 'pointer',
        padding: '6px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        borderRadius: '4px',
        transition: 'all 0.2s',
        fontSize: '14px'
    };

    return (
        <div style={{
            position: 'fixed',
            top: rect.top - 40, // Above the element
            left: rect.left,
            backgroundColor: '#1e1e1e',
            border: '1px solid #333',
            borderRadius: '6px',
            display: 'flex',
            gap: '4px',
            padding: '4px',
            zIndex: 10010,
            boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
            pointerEvents: 'auto'
        }}
            onMouseDown={(e) => e.stopPropagation()} // Prevent deselection
        >
            <button style={buttonStyle} onClick={handleParent} title="Select Parent (Esc)">
                ‚¨ÜÔ∏è
            </button>
            <div style={{ width: '1px', backgroundColor: '#333', height: '14px' }} />

            {/* SMART ACTIONS */}
            {(state.elements[elementId]?.type === 'text' || state.elements[elementId]?.type === 'button' || state.elements[elementId]?.type === 'label') && (
                <button style={buttonStyle} onClick={(e) => {
                    e.stopPropagation();
                    setEditingElementId(elementId);
                }} title="Edit Text">
                    ‚úèÔ∏è
                </button>
            )}
            {state.elements[elementId]?.type === 'image' && (
                <button style={buttonStyle} onClick={(e) => {
                    e.stopPropagation();
                    const url = prompt("Enter Image URL", state.elements[elementId]?.content || "");
                    if (url) updateElementProp(elementId, 'content', url); // Assuming content stores URL for image, or src prop if separate
                    // Check ElementRenderer: image uses 'src' binding usually or content if simple. 
                    // Wait, previous types showed 'content' is generic. for image it might be bound.
                    // Let's assume content for now or check types. 
                    // Looking at ElementRenderer (viewed previously), <img src={src} ... /> where src = resolveBinding('src', element.content).
                    // So updating 'content' updates the image source.
                }} title="Replace Image">
                    üñºÔ∏è
                </button>
            )}
            {(state.elements[elementId]?.type === 'container' || state.elements[elementId]?.type === 'section') && (
                <button style={buttonStyle} onClick={(e) => {
                    e.stopPropagation();
                    const currentGap = state.elements[elementId]?.styles?.gap;
                    const nextGap = currentGap === '0px' ? '8px' : currentGap === '8px' ? '16px' : currentGap === '16px' ? '24px' : '0px';
                    updateElementStyles(elementId, { gap: nextGap });
                }} title="Cycle Gap (0, 8, 16, 24)">
                </button>
            )}
            {(state.elements[elementId]?.type === 'container' || state.elements[elementId]?.type === 'section' || state.elements[elementId]?.type === 'box') && (
                <button style={{ ...buttonStyle, color: 'var(--accent-teal)' }} onClick={handleMagicOptimize} title="Magic Optimize Layout (AI)">
                    ‚ú®
                </button>
            )}

            <div style={{ width: '1px', backgroundColor: '#333', height: '14px' }} />

            <button style={buttonStyle} onClick={onOpenAnalytics} title="View Analytics">
                üìä
            </button>

            <button style={buttonStyle} onClick={handleReset} title="Reset Styles">
                ‚ü≤
            </button>
            <button style={buttonStyle} onClick={handleDuplicate} title="Duplicate">
                ‚ùê
            </button>
            <button style={buttonStyle} onClick={handleDelete} title="Delete (Del)">
                üóë
            </button>
        </div>
    );
}
